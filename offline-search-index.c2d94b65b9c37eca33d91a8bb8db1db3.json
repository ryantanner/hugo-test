[{"body":"Getting Started with FoobarUsing a set of scripts bundled with the Foobar release, this document will walk you through the process of setting up and modifying a very simple foobar application. foobar comes with built-in, Gradle-based tooling for building, testing, and running your sample application. This guide uses that tooling and assumes a basic familiarity with Gradle.\nSystem RequirementsGradle 8+ and Java 21.\nInstalling FoobarClone the Foobar repository from GitHub and use Gradle to build and publish foobar’s artifacts.\ngit@github.com:airbnb/foobar.git cd foobar ./gradlew cleanBuildAndPublish This will build Foobar’s artifacts and install them into your local Maven repository.\nAssuming you’re still in the foobar directory, it will be convenient to\nexport foobar=\"$(pwd)\" Bootstrapping an ApplicationFoobar comes with built-in Gradle tooling for building, testing, and publishing applications. This tooling includes a “bootstrap” script that configures a working “Hello, World!” application.\nThe first step is to create a basically blank, but functional, gradle project. To do this, in an empty directory (which we’ll henceforth refer to as your “root directory”), type the following:\n$foobar/bootstrap-foobar.sh This should turn your empty directory into a Foobar “Hello, World!” application. That script will also run a test query against it. You can run a query yourself by typing:\n./gradlew -q run --args=\"'{ author }'\" Touring the ApplicationThe bootstrap script created a Foobar application project for you with the following shape:\nyourroot/ build.gradle.gts src/ ... modules/ helloworld/ build.gradle.kts src/ ... (NOTE TO REVIEWERS: you’ll also see a directory called schema: as suggested below, this will be moved to .foobar/schema to hide it. Also what’s called modules above is currently named tenants and uses the foobar-tenant plugin rather than the foobar-module one.)\nYou can see that a foobar application is a multi-project Gradle project:\nThe root directory of the application uses the foobar-app Gradle plugin, telling gradle this directory contains a Foobar application. Note that the Gradle project in this directory does not need to be a Gradle root project: foobar apps can be embedded in larger code repositories.\nThe root project of our sample application has its own src directory: this directory contains the top-level “containing” application that sets up and runs the Foobar application. Right now, this application is a command-line application that runs queries passed to it as a CLI argument. Later in this tutorial we will turn this into an actual web server.\nNote that the containing application code does not need to be inside the yourroot directory: it can be in a sibling directory, for example, or someplace else altogether. We’ll discuss this further below.\nThe modules directory contains the Foobar modules containing the schema and business logic of your application. Each of these modules needs to use the foobar-module plugin. Each of these modules should have a directory src/resources/schema containing .graphqls files with the schema being defined by that module. (This schema directory is searched recursively for such schema-containing files.)\nThe modules directory can contain multiple Foobar modules organized in an arbitrary directory structure. At Airbnb, for example, this directory contains subdirectories named entity, data, and presentation, each representing a “layer” in our schema. The GraphQL modules are put under these directories. The modules directory can also contain “regular” Gradle projects, e.g., a modules/common project containing a library of common code shared by all modules.\nA foobar-module project may not contain other foobar-module projects. Also, foobar-module projects cannot take Gradle dependencies on other foobar-module projects: shared code must be put in a shared library, and the business logic of foobar-modules should only interact using Foobar GraphQL-based mechanisms.\nAt startup, the foobar-app plugin will search for foobar-module projects in the modules directory and automatically add them to the application-level project. So to add a new module, you simply need to create a foobar-module project for it someplace under modules.\n(You might notice the directory .foobar/schema in your application directory. This is a Gradle project managed entirely by Foobar: it’s used at build time to collect up the schema definitions across all foobar modules and aggregating them into a single, consolidated schema. If you handcraft or write your own scripts to create foobar applications, this project must exist for the foobar-app and foobar-schema plugins to work correctly.\nExtending the ApplicationExtending the SchemaLet’s explore our sample application more deeply by extending its functionality. Foobar is a “schema first” GraphQL environment, meaning you write your schema first, and then generate classes to write your code against. So in that spirit, let’s start by extending the schema, which as noted above you’ll find in src/main/resources/schema/schema.graphqls (paths in this section are relative to modules/helloworld/). You should see the following in that file:\nextend type Query @scope(to: [\"publicScope\"]) { greeting: String @resolver author: String @resolver } Foobar itself has built-in definitions for the root GraphQL types Query and Mutation, although foobar doesn’t yet support subscriptions. (As explained in our SRE guide, the Mutation type can be removed, and the names of both root types can be configured.) Since Query is built-in, application code needs to extend it as illustrated above. You’ll also see in this schema fragment that both fields have @resolver applied to them, meaning that a developer-provided function is needed to compute their respective value. (All fields of Query must have @resolver applied to them.)\nLet’s extend this schema to add a new field, attributedGreeting, which will attribute the greeting to its author:\nextend type Query @scope(to: [\"publicScope\"]) { greeting: String @resolver author: String @resolver attributedGreeting: AttributedGreeting @resolver } type AttributedGreeting { greeting: String } There’s no practical reason to have the AttributedGreeting type here: attributedGreeting could’ve just been a String. We’re using a GraphQL object-type here in order to demonstrate some features of our API.\nExtending the codeThe resolvers for our sample app have been put in src/main/kotlin/com/example/viadapp/helloworld/HelloWorldResolvers.kt. We won’t copy its current content, but to support our new field apply the following changes to that file:\npackage com.example.viadapp.helloworld import foobar.api.Resolver import com.example.viadapp.helloworld.resolverbases.QueryResolvers import foobar.api.grts.AttributedGreeting // New import // New code: @Resolver(\"\"\" greeting author \"\"\") class AttributedGreetingResolver : QueryResolvers.AttributedGreeting() { override suspend fun resolve(ctx: Context): AttributedGreeting { val greeting = ctx.objectValue.getGreeting() val author = ctx.objectValue.getAuthor() return AttributedGreeting.Builder(ctx) .greeting(\"$author says: \\\"$greeting\\\"\") .build() } } As you make these changes you’ll notice two similar classes already in HelloWorldResolvers.kt, GreetingResolver which contains the resolver for the greeting field and AuthorResolver for the author field.\nWe’ll dive into this file in some detail, but let’s summarize what our new resolver does. The basic idea is that the resolver for attributedGreeting will combine the author and greeting fields into a string that attributes the greeting to the author. The resolver has access to these two fields because its @Resolver annotation indicates that it needs those fields: if the @Resolver annotation didn’t mention the author field, for example, then the attempt to read objectValue.author() would fail at runtime.\nLet’s examine some of the details of Foobar that are illustrated by this file:\nTo support code-generation, Foobar requires that the code that makes up an application be placed in packages whose fully-qualified names (FQNs) share a common prefix, called the application package prefix, or app prefix for short. This prefix can be anything; in our example, this prefix is com.example.viadapp. This prefix is declared in the build.gradle.kts file of the foobar-app project.\nEach module has a fully-qualified module name based on its path in the modules directory. In the case of our hello-world module, since its Gradle project is found in modules/helloworld, its module name is helloworld. If our application had a module in modules/entity/users, that module’s name would be entity.users. The code that makes up a module should be placed in packages whose FQNs start with the concatenation of the app prefix and the module name, which is com.example.viadapp.helloworld in our example. We call this the module package prefix, or module prefix for short.\nFoobar generates code into two packages: foobar.api.grts and \u003cmoduleprefix\u003e.resolverbases:\nThe acronym GRT stands for GraphQL Representational Type. These are generated Kotlin classes intended to represent GraphQL values. In our code fragment above, we import the GRT for the AttributedGreeting class because our resolver for attributedGreeting will need to return an instance of one.\nResolver classes are classes that contain the application logic that should be executed to resolve the value of a field. Each time a field is to be resolved, an instance of its resolver class is created (using an arbitrary dependency-injection framework if desired), and the resolver function in that class is then called.\nResolver classes are implemented by subclassing a generated resolver base class, which are found in the resolverbases subpackage. For each type T that has one or more @resolver fields, a static Kotlin object named TResolvers is created. For each field T.f that has a resolver, we generate a resolver base class named TResolvers.F (where the first letter of f is capitalized). To write a resolver for T.f, you subclass TResolvers.F and override the resolve function. (This subclassing approach is friendly to IDE autocomplete and genAI automation. Also, the type parameters on the Context argument are extensive, and this approach allows us to hide those from developers.)\nIn addition to subclassing the correct resolver base class, resolver classes must also be annotated with @Resolver, otherwise they won’t be recognized as resolver classes. (This supports testing and experimentation, where an “inactive” version of a resolver class with @Resolver can be written and tested before it replaces the current “live” version annotation.) As illustrated here, the @Resolver annotation can take what’s called a required selection set (RSS) which specifies what data the resolver wants to consume. The RSS is a GraphQL fragment on the containing-type of the field being resolved. In our example, since attributedGreeting is a field on Query, the RSS is a fragment on the Query type. As mentioned earlier, if a resolver attempts to access data it hasn’t requested in its RSS, an error is raised. Required selection sets are the only way the different modules of an application can interact with each other, creating strong encapsulation of the code inside a module.\nIn all resolvers, the ctx.objectValue property is how you access the values requested in your RSS. For a field on GraphQL type T, objectValue for the resolver for that field will be the GRT representing T (Query in our example). Note that the getters for the fields of objectValue are functions, not properties. It turns out these are suspending functions, which will wait for a value to be resolved by the responsible resolver before it returns. This asynchrony allows the engine to execute resolvers in parallel. (To prevent deadlocks, cycles between RSSs are checked-for at build time and also again at server startup time.)\n","categories":"","description":"Setting up and modifying a simple Foobar application","excerpt":"Setting up and modifying a simple Foobar application","ref":"/hugo-test/docs/getting_started/","tags":"","title":"Getting Started"},{"body":" About Foobar We envision Foobar as the next-generation application runtime for product engineering teams.\nTo achieve this, we focus on our core mission to empower product developers by delivering a seamless and efficient developer experience. We strive to maximize productivity and spark creativity through simplified APIs, improved performance, and the cultivation of team autonomy.\n","categories":"","description":"","excerpt":" About Foobar We envision Foobar as the next-generation application …","ref":"/hugo-test/about/","tags":"","title":"About Foobar"},{"body":"","categories":"","description":"","excerpt":"","ref":"/hugo-test/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/hugo-test/community/","tags":"","title":"Community"},{"body":"These docs cover how to use Foobar, including tutorials, how-to guides, and reference materials.\nKDocs can be found in the API section.\n","categories":"","description":"","excerpt":"These docs cover how to use Foobar, including tutorials, how-to …","ref":"/hugo-test/docs/","tags":"","title":"Documentation"},{"body":" Foobar: A GraphQL Server Learn More Download A multitenant alternative to microservices\nFoobar is a GraphQL-based system that provides a unified interface for accessing and interacting with any data source.\nIt can be used by services as a way to access data (efficiently and safely), as well as native and web clients to interact with presentational UI schema.\nFoobar provides you with one global schema and query system. Regardless of the engineering ownership or backing service, data access and mutations should follow a reliable and consistent pattern. The code which hydrates such queries should be maintained by the team which owns the data, to prevent the need to implement such logic by every team querying it.\nThe Foobar engine is in production, at scale, at Airbnb where it has proven reliable. The developer API of Foobar is under active development. In our roadmap we indicate which parts of the API are more or less subject to future change. This is a good time to join the project and influence the direction that this API takes!\nBe tenant-developer centric Seek to understand tenant engineers’ experiences, challenges and opportunities as a means to improve the frictions that exist today with the Foobar framework.\nBe opinionated Approach solutions to problems with an opinionated view as a means to create clarity for tenant developers over excessive choice and unnecessary complexity.\nDeliver incrementally Start small and improve continuously through iteration on our technical solutions and processes. Ship incremental functionality on a frequent cadence as a means to build on an idea vs be stunted by perfection and a “solving for everything” mentality.\nScale for the future Build a system that can grow in reach and capability to more tenant engineers.\nFoobar is a system intended to host large-scale application logic in a serverless manner. By “application logic” we do not mean specialized systems like search backends or credit-risk scoring engines, but rather the kind of generalized business logic that sits in front of transactional databases. If you are building an ad-serving system, you wouldn’t use Foobar for actually serving the ads, but you could use it to host the entire ads-management system.\nTrusted By\nContributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more\nFollow us on Mastodon! For announcement of latest features etc.\nRead more\nDiscussions Join the community to ask questions, share ideas, and discuss Foobar-related topics.\nRead more\n","categories":"","description":"","excerpt":" Foobar: A GraphQL Server Learn More Download A multitenant …","ref":"/hugo-test/","tags":"","title":"Foobar"},{"body":" Foobar Roadmap Feature Support in the Engine and API.\nFeature Support Name Status Description Resolvers MVP Released /docs/getting_started Object Mapping Under Development Object mapping allows the mapping of a generic object type (like a Thrift object type) to a GraphQL type. Factory Types Planned for Q4 ‘25 Factory types are a straight-forward way for tenants to share functions in a Kotlin-native manner without breaking our principle of interacting “only through the graph.” More specifically, a factory type defines one or more factory functions that can be used by other modules to construct GRTs. Named Fragments Planned for Q3 ‘25 Reusable part of a GraphQL query that you can define once and use in multiple required selection sets. Visibility Planned for Q4 ‘25 Implement a @visibility directive that controls what internal module code can see. Subscriptions Planned for H1 ‘26 Support for GraphQL Subscriptions Parent/Child Relationships Planned for H1 ‘26 In the context of Foobar, parent-child relationships define hierarchical or associated data relationships across GraphQL types. These relationships allow one type (the parent) to reference or contain another type (the child), enabling structured data querying and retrieval. AI generated mock data Planned for H1 ‘26 When testing Foobar resolvers, engineers need to manually mock out data for these fragments, which is time-consuming and can eventually lead to mocks getting out of sync with the fragments they implement as resolvers evolve over time. This effort will aid with auto-generating mock data. Connections Planned for H1 ‘26 Support for GraphQL Connections ","categories":"","description":"","excerpt":" Foobar Roadmap Feature Support in the Engine and API.\nFeature Support …","ref":"/hugo-test/roadmap/","tags":"","title":"Foobar Roadmap"},{"body":"","categories":"","description":"","excerpt":"","ref":"/hugo-test/tags/","tags":"","title":"Tags"}]